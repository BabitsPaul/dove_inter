#include "langdef.h"
#include "const.h"
#include "..\util\util.h"

#include <map>
using namespace std;
using namespace ldef;

//////////////////////////////////////////////////////////////////////////////////////////////////
// structdef.cpp
//////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////
// AbstractStructDef
//
// Definition of the baseclass for all definitions of languages elements
//////////////////////////////////////////////////////////////////////////////////////////////////

AbstractStructDef::AbstractStructDef(char* name) {
	this->name = name;

	defMap.insert(pair<string, AbstractStructDef*>(name, this));
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// definition for textelements
//
// all other elements are based on textelements
// supported characters by this type is a subset of ASCII for general types
// and UNICODE for strings
//////////////////////////////////////////////////////////////////////////////////////////////////

Text::Text() :AbstractStructDef("text") {}

bool Text::validateNextChar(wchar_t c)
{
	//code tokens may not exceed the range of ascii signs
	//the interpretation of string literals is delegated to
	//the stringinterpreter and thus not relevant in this scope
	if (c > sizeof(char))
		return false;

	if (!util::contains(reinterpret_cast<const wchar_t*>(valid) , sizeof(valid) , c))
		return false;

	return true;
}

AbstractStructDef* Text::delegateTo(wchar_t c) {
	if (c == stringDelimiter)
		return defMap.at("string");

	return this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Block
//
// Definition of blockstatements
//////////////////////////////////////////////////////////////////////////////////////////////////

Block::Block() :AbstractStructDef("block") {
	inBlockStatement = false;
}

bool Block::validateNextChar(wchar_t c) {
	return false;
}

AbstractStructDef* Block::delegateTo(wchar_t c) {
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Expression
//
// Definition of Expressions
//////////////////////////////////////////////////////////////////////////////////////////////////

Expression::Expression() :AbstractStructDef("expression") {}

bool Expression::validateNextChar(wchar_t c) {
	return false;
}

AbstractStructDef* Expression::delegateTo(wchar_t c) {
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Name
//
// Definition of Names
//////////////////////////////////////////////////////////////////////////////////////////////////

Name::Name() :AbstractStructDef("name") {}

bool Name::validateNextChar(wchar_t c) {
	return false;
}

AbstractStructDef* Name::delegateTo(wchar_t c) {
	return NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// Type
//
// Definition of typenames
////////////////////////////////////////////////////////////////////////////////////////////////

Type::Type() :AbstractStructDef("type") {}

bool Type::validateNextChar(wchar_t c) {
	return false;
}

AbstractStructDef* Type::delegateTo(wchar_t c) {
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// AccessModifier
//
// Definition of accessmodifiers
/////////////////////////////////////////////////////////////////////////////////////////////////

AccessModifier::AccessModifier() :AbstractStructDef("accessmodifier") {}

bool AccessModifier::validateNextChar(wchar_t c) {
	return false;
}

AbstractStructDef* AccessModifier::delegateTo(wchar_t c) {
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Class
//
// Definition of Class
/////////////////////////////////////////////////////////////////////////////////////////////////

Class::Class() : AbstractStructDef("class") {}

bool Class::validateNextChar(wchar_t c) {
	return false;
}

AbstractStructDef* Class::delegateTo(wchar_t c) {
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Member
//
// Definition of Member
//////////////////////////////////////////////////////////////////////////////////////////////////

Member::Member() : AbstractStructDef("member") {}

bool Member::validateNextChar(wchar_t c)
{
	return false;
}

AbstractStructDef* Member::delegateTo(wchar_t c) {
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor
//
// Definition of Constructor
//////////////////////////////////////////////////////////////////////////////////////////////////

Constructor::Constructor() : AbstractStructDef("constructor") {}

bool Constructor::validateNextChar(wchar_t c)
{
	return false;
}

AbstractStructDef* Constructor::delegateTo(wchar_t c)
{
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Variable
// 
// Definition of Variable
//////////////////////////////////////////////////////////////////////////////////////////////////

Variable::Variable() : AbstractStructDef("variable") {}

bool Variable::validateNextChar(wchar_t c)
{
	return false;
}

AbstractStructDef* Variable::delegateTo(wchar_t c)
{
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Method
//
// Definition of Method
//////////////////////////////////////////////////////////////////////////////////////////////////

Method::Method() : AbstractStructDef("method") {}

bool Method::validateNextChar(wchar_t c)
{
	return false;
}

AbstractStructDef* Method::delegateTo(wchar_t c)
{
	return NULL;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Number
//
// Definition of Number
///////////////////////////////////////////////////////////////////////////////////////////////////

Number::Number() : AbstractStructDef("number") {}

bool Number::validateNextChar(char c)
{
	return false;
}

AbstractStructDef* Number::delegateTo(char c)
{
	return NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// String
// 
// Definition of String
////////////////////////////////////////////////////////////////////////////////////////////////////

String::String() : AbstractStructDef("string") {}

bool String::validateNextChar(char c)
{
	return false;
}

AbstractStructDef* String::delegateTo(char c)
{
	return NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// generate defmap
// 
// loader for generating a map with all definitions of 
// languagelements
////////////////////////////////////////////////////////////////////////////////////////////////

void generateDefMap()
{
	Text;
	AccessModifier;
	Block;
	Expression;
	Name;
	Text;
	Type;

	Class;
	Member;
	Variable;
	Method;
	Constructor;
}