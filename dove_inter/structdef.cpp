#include "structdef.h"
#include "const.h"

#include <map>
using namespace std;

//////////////////////////////////////////////////////////////////////////////////////////////////
// structdef.cpp
//////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////
// AbstractStructDef
//
// Definition of the baseclass for all definitions of languages elements
//////////////////////////////////////////////////////////////////////////////////////////////////

AbstractStructDef::AbstractStructDef(char* name) {
	this->name = name;

	defMap.insert(pair<string , AbstractStructDef*>(name, this));
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// definition for textelements
//
// all other elements are based on textelements
// supported characters by this type is a subset of ASCII for general types
// and UNICODE for strings
//////////////////////////////////////////////////////////////////////////////////////////////////

Text::Text() :AbstractStructDef("text") {}

bool Text::validateNextChar(wchar_t c)
{
	return false;
}

AbstractStructDef* Text::delegateTo(wchar_t c) {
	if (c == stringDelimiter)
	{
		return defMap.at("string");
	}

	return this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Block
//
// Definition of blockstatements
//////////////////////////////////////////////////////////////////////////////////////////////////

Block::Block():AbstractStructDef("block"){ }

bool Block::validateNextChar(wchar_t c) {
	return false;
}

AbstractStructDef* Block::delegateTo(wchar_t c) {
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Expression
//
// Definition of Expressions
//////////////////////////////////////////////////////////////////////////////////////////////////

Expression::Expression() :AbstractStructDef("expression") {}

bool Expression::validateNextChar(wchar_t c) {
	return false;
}

AbstractStructDef* Expression::delegateTo(wchar_t c) {
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Name
//
// Definition of Names
//////////////////////////////////////////////////////////////////////////////////////////////////

Name::Name() :AbstractStructDef("name") {}

bool Name::validateNextChar(wchar_t c) {
	return false;
}

AbstractStructDef* Name::delegateTo(wchar_t c) {
	return NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// Type
//
// Definition of typenames
////////////////////////////////////////////////////////////////////////////////////////////////

Type::Type() :AbstractStructDef("type") {}

bool Type::validateNextChar(wchar_t c) {
	return false;
}

AbstractStructDef* Type::delegateTo(wchar_t c) {
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// AccessModifier
//
// Definition of accessmodifiers
/////////////////////////////////////////////////////////////////////////////////////////////////

AccessModifier::AccessModifier() :AbstractStructDef("accessmodifier") {}

bool AccessModifier::validateNextChar(wchar_t c) {
	return false;
}

AbstractStructDef* AccessModifier::delegateTo(wchar_t c) {
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Class
//
// Definition of Class
/////////////////////////////////////////////////////////////////////////////////////////////////

Class::Class() : AbstractStructDef("class") {}

bool Class::validateNextChar(wchar_t c) {
	return false;
}

AbstractStructDef* Class::delegateTo(wchar_t c) {
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Member
//
// Definition of Member
//////////////////////////////////////////////////////////////////////////////////////////////////

Member::Member() : AbstractStructDef("member") {}

bool Member::validateNextChar(wchar_t c)
{
	return false;
}

AbstractStructDef* Member::delegateTo(wchar_t c) {
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor
//
// Definition of Constructor
//////////////////////////////////////////////////////////////////////////////////////////////////

Constructor::Constructor() : AbstractStructDef("constructor") {}

bool Constructor::validateNextChar(wchar_t c)
{
	return false;
}

AbstractStructDef* Constructor::delegateTo(wchar_t c)
{
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Variable
// 
// Definition of Variable
//////////////////////////////////////////////////////////////////////////////////////////////////

Variable::Variable() : AbstractStructDef("variable") {}

bool Variable::validateNextChar(wchar_t c)
{
	return false;
}

AbstractStructDef* Variable::delegateTo(wchar_t c)
{
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Method
//
// Definition of Method
//////////////////////////////////////////////////////////////////////////////////////////////////

Method::Method() : AbstractStructDef("method") {}

bool Method::validateNextChar(wchar_t c)
{
	return false;
}

AbstractStructDef* Method::delegateTo(wchar_t c)
{
	return NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// generate defmap
// 
// loader for generating a map with all definitions of 
// languagelements
////////////////////////////////////////////////////////////////////////////////////////////////

void generateDefMap()
{
	Text;
	AccessModifier;
	Block;
	Expression;
	Name;
	Text;
	Type;

	Class;
	Member;
	Variable;
	Method;
	Constructor;
}